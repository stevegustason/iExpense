//
//  ContentView.swift
//  iExpense
//
//  Created by Steven Gustason on 4/5/23.
//

import SwiftUI

// Creating a new struct to track the name, type, and amount of an expense. We use UUID as a unique ID automatically generated by Swift. Because we conform to the identifiable protocol, we don't need to tell our ForEach which property to use for the identifier. We also want to make sure our item is codable so we can use the JSONEncoder.
struct ExpenseItem: Identifiable, Codable {
    var id = UUID()
    let name: String
    let type: String
    let amount: Double
}

// Create an observable class to track our expenses
class Expenses: ObservableObject {
    // Create a published array of ExpenseItems so that announcements get sent when it's modified
    @Published var items = [ExpenseItem]() {
        didSet {
            // Here we create an instance of JSONEncoder that will convert our data to JSON, ask that to try encoding our items array, and then we write that to UserDefaults using the key “Items”
            if let encoded = try? JSONEncoder().encode(items) {
                UserDefaults.standard.set(encoded, forKey: "Items")
            }
        }
    }
    
    // Variable to filter only on personal expenses
    var personalItems : [ExpenseItem] {
        get { items.filter { $0.type == "Personal" } }
    }

    // Variable to filter only on business expenses
    var businessItems: [ExpenseItem] {
        get { items.filter { $0.type == "Business" } }
    }
    
    // Custom initializer to load the user's saved data
    init() {
        // First, load our UserDefaults data.
        if let savedItems = UserDefaults.standard.data(forKey: "Items") {
            // Then create an instance of the JSONDecoder and try to convert the data from UserDefaults into an array of ExpenseItem objects
            if let decodedItems = try? JSONDecoder().decode([ExpenseItem].self, from: savedItems) {
                // Then assign that array to items
                items = decodedItems
                return
            }
        }

        // If our decoding above doesn't work, set items to an empty array
        items = []
    }
}

struct ContentView: View {
    // Create an instance of our Expenses class using the StateObject wrapper so that Swift watches for changes
    @StateObject var expenses = Expenses()
    
    // Funcion to remove personal expenses
    func removePersonalItems(at offsets: IndexSet) {
      // Look at each item we are trying to delete
      for offset in offsets {
        // Look in the personalItems array and get that specific item we are trying to delete. Find it's corresponding match in the expenses.items array.
          if let index = expenses.items.firstIndex(where: {$0.id == expenses.personalItems[offset].id}) {
          // Delete the item from the expenses.items array at the index you found its match
            expenses.items.remove(at: index)
          }
        }
      }
    
    // Function to remove business expenses
    func removeBusinessItems(at offsets: IndexSet) {
      // Look at each item we are trying to delete
      for offset in offsets {
        // Look in the businessItems array and get that specific item we are trying to delete. Find it's corresponding match in the expenses.items array.
          if let index = expenses.items.firstIndex(where: {$0.id == expenses.businessItems[offset].id}) {
          // Delete the item from the expenses.items array at the index you found its match
            expenses.items.remove(at: index)
          }
        }
      }
    
    // Variable to track whether our add expense view is showing
    @State private var showingAddExpense = false
    
    var body: some View {
        NavigationView {
            List {
                // Split into two sections - one to display personal expenses, and one to display business expenses
                Section(header: Text("Personal Costs")) {
                    // Use a ForEach to have access to the onDelete() modifier. We use this ForEach to identify each expense, then print it out in a row. Since expenses conform to the identifiable protocol, we don't need to specify the id.
                    ForEach(expenses.personalItems) { item in
                        // Horizontal stack to have our expense name and type on the left, a spacer to force the items to each side, then the amount on the right
                        HStack {
                            // VStack to stack our bolded expense name and type
                            VStack(alignment: .leading) {
                                Text(item.name)
                                    .font(.headline)
                                Text(item.type)
                            }
                            
                            Spacer()
                            // Make sure our amount formatting is for the user's local currency
                            Text(item.amount, format: .currency(code: Locale.current.currency?.identifier ?? "USD"))
                            // Use the ternary opeerator to change the color of our expnses
                                .foregroundColor(item.amount < 10.0 ? .green : item.amount > 100 ? .red : .black)
                        }
                    }
                    // Add an onDelete modifier to our ForEach, calling removeItems to allow us to swipe to delete expenses.
                    .onDelete(perform: removePersonalItems)
                }
                Section(header: Text("Business Costs")) {
                    // Use a ForEach to have access to the onDelete() modifier. We use this ForEach to identify each expense, then print it out in a row. Since expenses conform to the identifiable protocol, we don't need to specify the id.
                    ForEach(expenses.businessItems) { item in
                        // Horizontal stack to have our expense name and type on the left, a spacer to force the items to each side, then the amount on the right
                        HStack {
                            // VStack to stack our bolded expense name and type
                            VStack(alignment: .leading) {
                                Text(item.name)
                                    .font(.headline)
                                Text(item.type)
                            }
                            
                            Spacer()
                            // Make sure our amount formatting is for the user's local currency
                            Text(item.amount, format: .currency(code: Locale.current.currency?.identifier ?? "USD"))
                            // Use the ternary opeerator to change the color of our expnses
                                .foregroundColor(item.amount < 10.0 ? .green : item.amount > 100 ? .red : .black)
                        }
                    }
                    // Add an onDelete modifier to our ForEach, calling removeItems to allow us to swipe to delete expenses.
                    .onDelete(perform: removeBusinessItems)
                }
            }
            .toolbar {
                Button {
                    showingAddExpense = true
                } label: {
                    Image(systemName: "plus")
                }
            }
        }
        .navigationTitle("iExpense")
        .sheet(isPresented: $showingAddExpense) {
            // We pass our existing expenses object from this view to the other
            AddView(expenses: expenses)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
